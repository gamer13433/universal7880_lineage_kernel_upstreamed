--- drivers/clocksource/exynos_mct.c
+++ drivers/clocksource/exynos_mct.c
@@ -466,12 +466,15 @@ static int exynos4_local_timer_setup(struct clock_event_device *evt)
 	exynos4_mct_write(TICK_BASE_CNT, mevt->base + MCT_L_TCNTB_OFFSET);
 
 	if (mct_int_type == MCT_INT_SPI) {
-
-		if (evt->irq == -1)
+		evt->irq = mct_irqs[MCT_L0_IRQ + cpu];
+		if (request_irq(evt->irq, exynos4_mct_tick_isr,
+				IRQF_TIMER | IRQF_NOBALANCING,
+				evt->name, mevt)) {
+			pr_err("exynos-mct: cannot register IRQ %d\n",
+				evt->irq);
 			return -EIO;
-
-		irq_force_affinity(evt->irq, cpumask_of(cpu));
-		enable_irq(evt->irq);
+		}
+		irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));
 	} else {
 		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);
 	}
@@ -484,12 +487,10 @@ static int exynos4_local_timer_setup(struct clock_event_device *evt)
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	evt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);
-	if (mct_int_type == MCT_INT_SPI) {
-		if (evt->irq != -1)
-			disable_irq_nosync(evt->irq);
-	} else {
+	if (mct_int_type == MCT_INT_SPI)
+		free_irq(evt->irq, this_cpu_ptr(&percpu_mct_tick));
+	else
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
-	}
 }
 
 static int exynos4_mct_cpu_notify(struct notifier_block *self,
