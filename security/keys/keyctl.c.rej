--- security/keys/keyctl.c
+++ security/keys/keyctl.c
@@ -277,8 +277,7 @@ error:
  * Create and join an anonymous session keyring or join a named session
  * keyring, creating it if necessary.  A named session keyring must have Search
  * permission for it to be joined.  Session keyrings without this permit will
- * be skipped over.  It is not permitted for userspace to create or join
- * keyrings whose name begin with a dot.
+ * be skipped over.
  *
  * If successful, the ID of the joined session keyring will be returned.
  */
@@ -295,16 +294,12 @@ long keyctl_join_session_keyring(const char __user *_name)
 			ret = PTR_ERR(name);
 			goto error;
 		}
-
-		ret = -EPERM;
-		if (name[0] == '.')
-			goto error_name;
 	}
 
 	/* join the session */
 	ret = join_session_keyring(name);
-error_name:
 	kfree(name);
+
 error:
 	return ret;
 }
@@ -744,11 +739,6 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	key = key_ref_to_ptr(key_ref);
 
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
-		ret = -ENOKEY;
-		goto error2;
-	}
-
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
@@ -767,16 +757,16 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	/* the key is probably readable - now try to read it */
 can_read_key:
-	ret = -EOPNOTSUPP;
-	if (key->type->read) {
-		/* Read the data with the semaphore held (since we might sleep)
-		 * to protect against the key being updated or revoked.
-		 */
-		down_read(&key->sem);
-		ret = key_validate(key);
-		if (ret == 0)
+	ret = key_validate(key);
+	if (ret == 0) {
+		ret = -EOPNOTSUPP;
+		if (key->type->read) {
+			/* read the data with the semaphore held (since we
+			 * might sleep) */
+			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
-		up_read(&key->sem);
+			up_read(&key->sem);
+		}
 	}
 
 error2:
